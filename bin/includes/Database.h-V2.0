//用new定义数组
//能更大
#ifndef DATABASE_H
#define DATABASE_H 1

#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<map>

#define NR 1000
#define SON 100

struct Node {
	int siz, k;
	std::string val;
	Node *l, *r;
	Node() {
		k = siz = 0;
		val = "";
		l = r = NULL;
	}
	void Update() {
		siz = (l == NULL ? 0 : l->siz) + (r == NULL ? 0 : r->siz) + 1;
	}
};
struct Splay {
	private:
	Node *_root;
	void New(Node *&p, std::string val) {
		p = new Node;
		p->val = val;
		p->siz = 1;
	}
	void RotateL(Node *&p) {
		Node *q = p->r;
		p->r = q->l;
		q->l = p;
		p->Update();
		p = q;
		p->Update();
	}
	void RotateR(Node *&p) {
		Node *q = p->l;
		p->l = q->r;
		q->r = p;
		p->Update();
		p = q;
		p->Update();
	}
	void Splay_(Node *&p, std::string val) {
		if (p->val == val) {
			return;
		}
		if (p->val > val) {
			if (p->l->val == val) {
				RotateR(p);
			} else if (p->l->val > val) {
				Splay_(p->l->l, val);
				RotateR(p);
				RotateR(p);
			} else {
				Splay_(p->l->r, val);
				RotateL(p->l);
				RotateR(p);
			}
		} else {
			if (p->r->val == val) {
				RotateL(p);
			} else if (p->r->val < val) {
				Splay_(p->r->r, val);
				RotateL(p);
				RotateL(p);
			} else {
				Splay_(p->r->l, val);
				RotateR(p->r);
				RotateL(p);
			}
		}
	}
	void Update_(Node *&p, std::string s, int k) {
		if (p == NULL) {
			New(p, s);
			p->k = k;
			return;
		}
		if (p->val == s) {
			p->k = k;
		} else if (p->val > s) {
			Update_(p->l, s, k);
		} else {
			Update_(p->r, s, k);
		}
		p->Update();
	}
	int Query_(Node *p, std::string s) {
		if (p == NULL) {
			return 0;
		}
		if (p->val == s) {
			return p->k;
		} else if (p->val > s) {
			return Query_(p->l, s);
		} else {
			return Query_(p->r, s);
		}
	}
	void Destruct(Node *&p) {
		if (p == NULL) {
			return;
		}
		Destruct(p->l);
		Destruct(p->r);
		delete p;
	}
	public:
	Splay() {
		New(_root, "!");
		New(_root->r, "~");
	}
	void Update(std::string s, int k) {
		Update_(_root, s, k);
		Splay_(_root, s);
	}
	int Query(std::string s) {
		return Query_(_root, s);
	}
	~Splay() {
		Destruct(_root);
	}
};
struct word_chain{
	Splay indexof;
	std::string stringof[NR];
	int last_part_index/*最后一个组的编号*/;
	int** son;
	int *son_t;
	//int not_son[NR][NR],not_son_t[NR];
	//记录该声韵母组后面可以或者不可以接什么
	word_chain() {
		son = new int*[NR];
		for (int i = 0;i < NR;i++)
			son[i] = new int[SON];
		son_t = new int[NR];
		last_part_index = 0;
		for (int i = 0;i < NR;i++)
			memset(son[i] ,-1 ,SON*sizeof(int));
		memset(son_t, 0, NR*sizeof(int));
		printf("Variable initialization completed.\n");
		//memset(not_son,-1,sizeof(not_son));
		//memset(not_son_t,0,sizeof(not_son_t));
	}
	void freespace() {
		for(int i = 0;i < NR;i++)
			delete[] son[i];
		delete[] son;
		delete[] son_t;
	}
	//-----------------------------function using map start--------------------------------------
	inline int newstr(std::string str){
		int hasid=indexof.Query(str);
		if(hasid)return hasid;
		indexof.Update(str, ++last_part_index);
		stringof[last_part_index]=str;
		return last_part_index; 
	}
	inline void push_next(std::string cur,std::string next){
		int id_cur=newstr(cur);
		int id_next=newstr(next);
		son[id_cur][++son_t[id_cur]]=id_next;
	}
	inline void print(){
		for(int i=1;i<=last_part_index;i++){
			printf("num:%d\tstring:",i);
			std::cout<<stringof[i]<<"\tsons:[";
			for(int j=1;j<=son_t[i];j++){
				printf(" %d",son[i][j]);
				if(son[i][j]>0)
					std::cout<<stringof[son[i][j]];
				else printf("**<0**");
			}
			printf(" ]\n");
		}
	}
	//-----------------------------function using map end--------------------------------------
	//第一个参数:统计并清除法编号为strnum的节点的子节点
	//第二个参数:清除出现次数少于k的
	void clean(int strnum,int k){
		std::sort(son[strnum]+1,son[strnum]+son_t[strnum]+1);
		int cnt=0;
		for(int i=son_t[strnum];i>=1;i--){
			if(son[strnum][i]==son[strnum][i-1] && (i>=1)){
				cnt++;
				son[strnum][i]=-1;
			}
			else {
				if(cnt<(k-1))
					son[strnum][i]=-1;
				cnt=0;
			}
		}
		int index_of_done=1;
		for(int i=1;i<=son_t[strnum];i++){
			if(son[strnum][i]==-1)continue;
			son[strnum][index_of_done]=son[strnum][i];
			if(i!=index_of_done)son[strnum][i]=-1;
			index_of_done++;
		}
		son_t[strnum]=index_of_done-1;
	}
	~word_chain() {
		freespace();
	}
};

#undef NR
#undef SON

#endif
